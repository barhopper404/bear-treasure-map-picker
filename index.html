<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BEAR Guild - Treasure Map Team Picker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1428188591263191120';
        const REDIRECT_URI = 'https://barhopper404.github.io/bear-treasure-map-picker/';
        
        // IMPORTANT: Replace this with your Google Apps Script Web App URL
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwSZmzTPP43TD36KdccG4rw6P6NJtN2KbWBK8VW_OOHUzC3vE5NkrKN990EKThKAYU1/exec';
        
        // Lucide React icons as simple SVG components
        const Users = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
                <circle cx="9" cy="7" r="4"/>
                <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
        );
        
        const Shield = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
            </svg>
        );
        
        const Key = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <circle cx="7.5" cy="15.5" r="5.5"/>
                <path d="m21 2-9.6 9.6"/>
                <path d="m15.5 7.5 3 3L22 7l-3-3"/>
            </svg>
        );
        
        const Heart = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/>
            </svg>
        );
        
        const Music = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
        );
        
        const Copy = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
            </svg>
        );
        
        const Check = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <polyline points="20 6 9 17 4 12"/>
            </svg>
        );

        const RefreshCw = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M21 2v6h-6"/>
                <path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
                <path d="M3 22v-6h6"/>
                <path d="M21 12a9 9 0 0 1-15 6.7L3 16"/>
            </svg>
        );

        const Edit = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
        );

        const Trash = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M3 6h18"/>
                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/>
                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
            </svg>
        );

        function TreasureMapTeamPicker() {
          const [view, setView] = useState('home');
          const [eventId, setEventId] = useState('');
          const [eventData, setEventData] = useState(null);
          const [characterName, setCharacterName] = useState('');
          const [wantsCaptain, setWantsCaptain] = useState(false);
          const [isLockpicker, setIsLockpicker] = useState(false);
          const [isHealer, setIsHealer] = useState(false);
          const [isBard, setIsBard] = useState(false);
          const [linkCopied, setLinkCopied] = useState(false);
          const [captains, setCaptains] = useState([]);
          const [pickingCaptain, setPickingCaptain] = useState(0);
          const [firstPickerDeferred, setFirstPickerDeferred] = useState(false);
          const [teams, setTeams] = useState({ captain1: [], captain2: [] });
          const [availablePlayers, setAvailablePlayers] = useState([]);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState('');
          const [editingPlayer, setEditingPlayer] = useState(null);
          const [spinningWheel, setSpinningWheel] = useState(false);
          const [wheelNames, setWheelNames] = useState([]);
          const [currentWheelName, setCurrentWheelName] = useState('');
          const [captainChoiceTimer, setCaptainChoiceTimer] = useState(45);
          const [draftTimer, setDraftTimer] = useState(60);
          const [hasJoined, setHasJoined] = useState(false);
          const [isAutoPicking, setIsAutoPicking] = useState(false);
          const [justDrafted, setJustDrafted] = useState(null);
          const [isDrafting, setIsDrafting] = useState(false);
          const [draftTimerSetting, setDraftTimerSetting] = useState(60);
          const [captainChoiceTimerSetting, setCaptainChoiceTimerSetting] = useState(45);
          const [teamNames, setTeamNames] = useState({ captain1: '', captain2: '' });
          const [editingTeamName, setEditingTeamName] = useState(null);
          const [tempTeamName, setTempTeamName] = useState('');
          const [editingRoles, setEditingRoles] = useState({});
          const [tempRoles, setTempRoles] = useState({});
          const [discordUser, setDiscordUser] = useState(null);
          const [isAuthenticating, setIsAuthenticating] = useState(false);
          const [leaderboard, setLeaderboard] = useState([]);
          const [showWinnerSelect, setShowWinnerSelect] = useState(false);
          const [totalMaps, setTotalMaps] = useState(20);
          const [mapCoords, setMapCoords] = useState('');
          const [parsedMaps, setParsedMaps] = useState([]);
          const [selectedMaps, setSelectedMaps] = useState([]);
          const [currentMapPicker, setCurrentMapPicker] = useState(0);
          const [mapPickingStarted, setMapPickingStarted] = useState(false);
          const [showAddPlayer, setShowAddPlayer] = useState(false);
          const [newPlayerName, setNewPlayerName] = useState('');
          const [newPlayerCaptain, setNewPlayerCaptain] = useState(false);
          const [newPlayerLockpicker, setNewPlayerLockpicker] = useState(false);
          const [newPlayerHealer, setNewPlayerHealer] = useState(false);
          const [newPlayerBard, setNewPlayerBard] = useState(false);

          // Check for event ID in URL on load
          useEffect(() => {
            const urlParams = new URLSearchParams(window.location.search);
            const eventParam = urlParams.get('event');
            const codeParam = urlParams.get('code');
            
            if (codeParam) {
              handleDiscordCallback(codeParam);
            } else if (eventParam) {
              setEventId(eventParam);
              const savedDiscord = localStorage.getItem('bearDiscordUser');
              if (savedDiscord) {
                setView('join');
              }
            }
          }, []);

          useEffect(() => {
            if (characterName) {
              try {
                localStorage.setItem('bearCharacterName', characterName);
              } catch (e) {
                console.log('localStorage not available:', e);
              }
            }
            if (discordUser) {
              try {
                localStorage.setItem('bearDiscordUser', JSON.stringify(discordUser));
              } catch (e) {
                console.log('localStorage not available:', e);
              }
            }
          }, [characterName, discordUser]);

          useEffect(() => {
            try {
              const savedName = localStorage.getItem('bearCharacterName');
              if (savedName) {
                setCharacterName(savedName);
              }
              const savedDiscord = localStorage.getItem('bearDiscordUser');
              if (savedDiscord) {
                setDiscordUser(JSON.parse(savedDiscord));
              }
            } catch (e) {
              console.log('localStorage not available:', e);
            }
            
            fetchLeaderboard();
          }, []);

          const fetchLeaderboard = async () => {
            try {
              const response = await fetch(`${SCRIPT_URL}?action=getLeaderboard`);
              const result = await response.json();
              if (result.success) {
                setLeaderboard(result.leaderboard || []);
              }
            } catch (err) {
              console.error('Error fetching leaderboard:', err);
            }
          };

          const recordWinner = async (winningTeam) => {
            if (!confirm(`Confirm ${winningTeam === 'captain1' ? eventData?.teamNames?.captain1 || `Team 1 (${captains[0]?.name})` : eventData?.teamNames?.captain2 || `Team 2 (${captains[1]?.name})`} won?`)) {
              return;
            }

            setLoading(true);
            try {
              const params = new URLSearchParams({
                action: 'recordWinner',
                eventId: eventId,
                winningTeam: winningTeam
              });

              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();

              if (result.success) {
                setEventData(result.eventData);
                setShowWinnerSelect(false);
                alert('Winner recorded! Stats have been updated.');
              } else {
                setError('Failed to record winner: ' + result.error);
              }
            } catch (err) {
              setError('Error recording winner: ' + err.message);
            } finally {
              setLoading(false);
            }
          };

          const handleDiscordCallback = async (code) => {
            setIsAuthenticating(true);
            try {
              const params = new URLSearchParams({
                action: 'exchangeCode',
                code: code
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              if (result.success) {
                setDiscordUser(result.user);
                window.history.replaceState({}, document.title, window.location.pathname + (eventId ? `?event=${eventId}` : ''));
                
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('event')) {
                  setView('join');
                }
              } else {
                setError('Discord authentication failed: ' + result.error);
              }
            } catch (err) {
              setError('Error during Discord authentication: ' + err.message);
            } finally {
              setIsAuthenticating(false);
            }
          };

          const loginWithDiscord = () => {
            const authUrl = `https://discord.com/api/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&scope=identify`;
            window.location.href = authUrl;
          };

          const logoutDiscord = () => {
            setDiscordUser(null);
            try {
              localStorage.removeItem('bearDiscordUser');
            } catch (e) {
              console.log('localStorage not available:', e);
            }
          };

          useEffect(() => {
            if ((view === 'lobby' || view === 'captainChoice' || view === 'teamPicking') && eventId) {
              const interval = setInterval(async () => {
                try {
                  const response = await fetch(`${SCRIPT_URL}?eventId=${eventId}`);
                  const result = await response.json();
                  if (result.success && result.eventData) {
                    const currentDataStr = JSON.stringify(eventData);
                    const newDataStr = JSON.stringify(result.eventData);
                    
                    if (currentDataStr !== newDataStr) {
                      setEventData(result.eventData);
                      
                      if (result.eventData.started && result.eventData.captains) {
                        setCaptains(result.eventData.captains);
                        
                        if (result.eventData.currentPicker !== pickingCaptain) {
                          setPickingCaptain(result.eventData.currentPicker || 0);
                        }
                        
                        const currentTeamsStr = JSON.stringify(teams);
                        const newTeamsStr = JSON.stringify(result.eventData.teams);
                        if (currentTeamsStr !== newTeamsStr && result.eventData.teams) {
                          setTeams(result.eventData.teams);
                        }
                        
                        const currentAvailableStr = JSON.stringify(availablePlayers);
                        const newAvailableStr = JSON.stringify(result.eventData.availablePlayers);
                        if (currentAvailableStr !== newAvailableStr && result.eventData.availablePlayers) {
                          setAvailablePlayers(result.eventData.availablePlayers);
                        }
                        
                        if (view === 'lobby' && result.eventData.started) {
                          setView('captainChoice');
                        }
                        if (view === 'captainChoice' && result.eventData.deferredFirstPick !== undefined) {
                          setFirstPickerDeferred(result.eventData.deferredFirstPick);
                          if (result.eventData.deferredFirstPick || (result.eventData.teams && (result.eventData.teams.captain1.length > 0 || result.eventData.teams.captain2.length > 0))) {
                            setView('teamPicking');
                          }
                        }
                        if (result.eventData.completed) {
                          setView('complete');
                        }
                      }
                    }
                  }
                } catch (err) {
                  console.error('Error polling for updates:', err);
                }
              }, 3000);
              
              return () => clearInterval(interval);
            }
          }, [view, eventId, eventData, teams, availablePlayers, pickingCaptain]);

          const generateEventId = () => {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
          };

          const createEvent = async () => {
            setLoading(true);
            setError('');
            
            const newEventId = generateEventId();
            const participant = {
              name: characterName,
              discordUser: discordUser,
              wantsCaptain: wantsCaptain,
              lockpicker: isLockpicker,
              healer: isHealer,
              bard: isBard,
              isMarshall: true
            };

            try {
              const params = new URLSearchParams({
                action: 'createEvent',
                eventId: newEventId,
                marshall: characterName,
                discordUser: JSON.stringify(discordUser),
                participantData: JSON.stringify([participant])
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              if (result.success) {
                setEventId(newEventId);
                setEventData(result.eventData);
                setView('lobby');
              } else {
                setError('Failed to create event: ' + result.error);
              }
            } catch (err) {
              setError('Error creating event. Please try again. Error: ' + err.message);
              console.error('Create event error:', err);
            } finally {
              setLoading(false);
            }
          };

          const joinEvent = async () => {
            if (hasJoined) {
              setError('You have already joined this event!');
              return;
            }

            setLoading(true);
            setError('');

            const participant = {
              name: characterName,
              discordUser: discordUser,
              wantsCaptain,
              lockpicker: isLockpicker,
              healer: isHealer,
              bard: isBard,
              isMarshall: false
            };

            try {
              const checkResponse = await fetch(`${SCRIPT_URL}?eventId=${eventId}`);
              const checkResult = await checkResponse.json();
              
              if (!checkResult.success) {
                setError('Event not found: ' + checkResult.error);
                setLoading(false);
                return;
              }

              if (checkResult.eventData.started) {
                setError('This event has already started and is locked.');
                setLoading(false);
                return;
              }

              const existingNames = checkResult.eventData.participants.map(p => p.name.toLowerCase());
              if (existingNames.includes(characterName.toLowerCase())) {
                setError('A player with this name has already joined. Please choose a different character name.');
                setLoading(false);
                return;
              }
              
              const params = new URLSearchParams({
                action: 'addParticipant',
                eventId: eventId,
                participantData: JSON.stringify(participant)
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              console.log('Join result:', result);
              
              if (result.success) {
                setEventData(result.eventData);
                setHasJoined(true);
                setView('lobby');
              } else {
                setError('Failed to join event: ' + (result.error || 'Unknown error') + (result.debug ? ' - Debug: ' + JSON.stringify(result.debug) : ''));
              }
            } catch (err) {
              setError('Error joining event. Please check the Event ID and try again. Error: ' + err.message);
              console.error('Join event error:', err);
            } finally {
              setLoading(false);
            }
          };

          const copyEventLink = () => {
            const link = `${window.location.origin}${window.location.pathname}?event=${eventId}`;
            navigator.clipboard.writeText(link);
            setLinkCopied(true);
            setTimeout(() => setLinkCopied(false), 2000);
          };

          const spinWheel = (players) => {
            return players[Math.floor(Math.random() * players.length)];
          };

          const animateWheelSpin = (names, callback) => {
            setWheelNames(names);
            setSpinningWheel(true);
            
            let count = 0;
            const spinDuration = 3000;
            const intervalTime = 100;
            const totalSpins = spinDuration / intervalTime;
            
            const interval = setInterval(() => {
              setCurrentWheelName(names[count % names.length].name);
              count++;
              
              if (count >= totalSpins) {
                clearInterval(interval);
                const winner = spinWheel(names);
                setCurrentWheelName(winner.name);
                
                setTimeout(() => {
                  setSpinningWheel(false);
                  callback(winner);
                }, 1000);
              }
            }, intervalTime);
          };

          const startEvent = async () => {
            const potentialCaptains = eventData.participants.filter(p => p.wantsCaptain);
            
            if (potentialCaptains.length < 2) {
              alert('Need at least 2 people willing to be captain!');
              return;
            }

            animateWheelSpin(potentialCaptains, (captain1) => {
              const remainingCaptains = potentialCaptains.filter(p => p.name !== captain1.name);
              
              setTimeout(() => {
                animateWheelSpin(remainingCaptains, async (captain2) => {
                  const firstPicker = Math.random() < 0.5 ? 0 : 1;
                  
                  const selectedCaptains = [captain1, captain2];
                  const nonCaptains = eventData.participants.filter(
                    p => p.name !== captain1.name && p.name !== captain2.name
                  );

                  const updatedEventData = {
                    ...eventData,
                    started: true,
                    captains: selectedCaptains,
                    firstPicker: firstPicker,
                    currentPicker: firstPicker,
                    availablePlayers: nonCaptains,
                    teams: { captain1: [], captain2: [] },
                    deferredFirstPick: false
                  };

                  try {
                    const params = new URLSearchParams({
                      action: 'updateEvent',
                      eventId: eventId,
                      eventData: JSON.stringify(updatedEventData)
                    });

                    await fetch(`${SCRIPT_URL}?${params.toString()}`);
                    
                    setCaptains(selectedCaptains);
                    setPickingCaptain(firstPicker);
                    setAvailablePlayers(nonCaptains);
                    setTeams({ captain1: [], captain2: [] });
                    setView('captainChoice');
                  } catch (err) {
                    setError('Error starting event: ' + err.message);
                  }
                });
              }, 1500);
            });
          };

          const deferFirstPick = async () => {
            setFirstPickerDeferred(true);
            
            const newCurrentPicker = pickingCaptain === 0 ? 1 : 0;
            setPickingCaptain(newCurrentPicker);
            
            const updatedEventData = {
              ...eventData,
              deferredFirstPick: true,
              currentPicker: newCurrentPicker
            };

            try {
              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              await fetch(`${SCRIPT_URL}?${params.toString()}`);
              setEventData(updatedEventData);
              setView('teamPicking');
            } catch (err) {
              setError('Error deferring pick: ' + err.message);
            }
          };

          const startDrafting = () => {
            setDraftTimer(draftTimerSetting);
            setView('teamPicking');
          };

          const handleCaptainTimeout = async () => {
            if (pickingCaptain === eventData.firstPicker) {
              const otherCaptain = pickingCaptain === 0 ? 1 : 0;
              setPickingCaptain(otherCaptain);
              setCaptainChoiceTimer(captainChoiceTimerSetting);
              
              const updatedEventData = {
                ...eventData,
                currentPicker: otherCaptain,
                firstPickerTimedOut: true
              };
              
              try {
                const params = new URLSearchParams({
                  action: 'updateEvent',
                  eventId: eventId,
                  eventData: JSON.stringify(updatedEventData)
                });
                await fetch(`${SCRIPT_URL}?${params.toString()}`);
                setEventData(updatedEventData);
              } catch (err) {
                console.error('Error updating after timeout:', err);
              }
            } else {
              const randomDefer = Math.random() < 0.5;
              if (randomDefer) {
                await deferFirstPick();
              } else {
                startDrafting();
              }
            }
          };

          const handleDraftTimeout = async () => {
            if (availablePlayers.length > 0 && !isAutoPicking) {
              setIsAutoPicking(true);
              const randomPlayer = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
              await pickPlayer(randomPlayer);
              setTimeout(() => setIsAutoPicking(false), 1000);
            }
          };

          useEffect(() => {
            if (view === 'captainChoice' && captainChoiceTimer > 0) {
              const timer = setTimeout(() => {
                setCaptainChoiceTimer(prev => prev - 1);
              }, 1000);
              return () => clearTimeout(timer);
            } else if (view === 'captainChoice' && captainChoiceTimer === 0) {
              handleCaptainTimeout();
            }
          }, [view, captainChoiceTimer]);

          useEffect(() => {
            if (view === 'teamPicking' && availablePlayers.length > 0 && draftTimer > 0 && !isAutoPicking) {
              const timer = setTimeout(() => {
                setDraftTimer(prev => prev - 1);
              }, 1000);
              return () => clearTimeout(timer);
            } else if (view === 'teamPicking' && draftTimer === 0 && availablePlayers.length > 0 && !isAutoPicking) {
              handleDraftTimeout();
            }
          }, [view, draftTimer, availablePlayers, isAutoPicking]);

          useEffect(() => {
            if (view === 'teamPicking' && !isAutoPicking) {
              setDraftTimer(draftTimerSetting);
            }
          }, [pickingCaptain, view, teams.captain1.length, teams.captain2.length, draftTimerSetting]);

          const pickPlayer = async (player) => {
            if (isDrafting) {
              return;
            }
            
            setIsDrafting(true);
            
            const teamKey = pickingCaptain === 0 ? 'captain1' : 'captain2';
            
            const newTeams = {
              ...teams,
              [teamKey]: [...teams[teamKey], player]
            };
            
            const newAvailablePlayers = availablePlayers.filter(p => p.name !== player.name);
            
            setTeams(newTeams);
            setAvailablePlayers(newAvailablePlayers);
            setDraftTimer(draftTimerSetting);
            setJustDrafted(player.name);
            setTimeout(() => setJustDrafted(null), 2000);
            
            try {
              const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
              audio.volume = 0.3;
              audio.play().catch(e => console.log('Audio play failed:', e));
            } catch (e) {
              console.log('Audio creation failed:', e);
            }
            
            const updatedEventData = {
              ...eventData,
              teams: newTeams,
              availablePlayers: newAvailablePlayers,
              currentPicker: pickingCaptain === 0 ? 1 : 0,
              teamNames: teamNames
            };

            try {
              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              await fetch(`${SCRIPT_URL}?${params.toString()}`);
              setEventData(updatedEventData);
            } catch (err) {
              console.error('Error updating teams:', err);
            }
            
            setTimeout(() => {
              setIsDrafting(false);
            }, 500);
            
            if (newAvailablePlayers.length === 1) {
              const otherTeamKey = pickingCaptain === 0 ? 'captain2' : 'captain1';
              const finalTeams = {
                ...newTeams,
                [otherTeamKey]: [...newTeams[otherTeamKey], newAvailablePlayers[0]]
              };
              
              setTeams(finalTeams);
              setAvailablePlayers([]);
              
              try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
                audio.volume = 0.5;
                audio.play().catch(e => console.log('Audio play failed:', e));
              } catch (e) {
                console.log('Audio creation failed:', e);
              }
              
              const finalEventData = {
                ...eventData,
                teams: finalTeams,
                availablePlayers: [],
                completed: true,
                teamNames: teamNames
              };

              try {
                const params = new URLSearchParams({
                  action: 'updateEvent',
                  eventId: eventId,
                  eventData: JSON.stringify(finalEventData)
                });

                await fetch(`${SCRIPT_URL}?${params.toString()}`);
              } catch (err) {
                console.error('Error finalizing teams:', err);
              }
              
              setView('complete');
            } else {
              setPickingCaptain(prev => prev === 0 ? 1 : 0);
            }
          };

          const addManualPlayer = async () => {
            if (!newPlayerName.trim()) {
              setError('Player name is required!');
              return;
            }

            const existingNames = eventData.participants.map(p => p.name.toLowerCase());
            if (existingNames.includes(newPlayerName.toLowerCase())) {
              setError('A player with this name already exists!');
              return;
            }

            setLoading(true);
            setError('');

            const manualPlayer = {
              name: newPlayerName,
              discordUser: {
                id: `manual_${Date.now()}`,
                username: `${newPlayerName} (Manual)`
              },
              wantsCaptain: newPlayerCaptain,
              lockpicker: newPlayerLockpicker,
              healer: newPlayerHealer,
              bard: newPlayerBard,
              isMarshall: false,
              isManual: true
            };

            try {
              const params = new URLSearchParams({
                action: 'addParticipant',
                eventId: eventId,
                participantData: JSON.stringify(manualPlayer)
              });

              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();

              if (result.success) {
                setEventData(result.eventData);
                setShowAddPlayer(false);
                setNewPlayerName('');
                setNewPlayerCaptain(false);
                setNewPlayerLockpicker(false);
                setNewPlayerHealer(false);
                setNewPlayerBard(false);
              } else {
                setError('Failed to add player: ' + result.error);
              }
            } catch (err) {
              setError('Error adding player: ' + err.message);
            } finally {
              setLoading(false);
            }
          };

          const removePlayer = async (playerIndex) => {
            if (!confirm('Are you sure you want to kick this player?')) {
              return;
            }

            setLoading(true);
            setError('');

            try {
              const updatedEventData = { ...eventData };
              updatedEventData.participants.splice(playerIndex, 1);

              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();

              if (result.success) {
                setEventData(result.eventData);
              } else {
                setError('Failed to remove player: ' + result.error);
              }
            } catch (err) {
              setError('Error removing player: ' + err.message);
              console.error('Remove player error:', err);
            } finally {
              setLoading(false);
            }
          };

          const updatePlayerRoles = async (playerIndex, updates) => {
            setLoading(true);
            setError('');

            try {
              const updatedEventData = { ...eventData };
              updatedEventData.participants[playerIndex] = {
                ...updatedEventData.participants[playerIndex],
                ...updates
              };

              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();

              if (result.success) {
                setEventData(result.eventData);
                setEditingPlayer(null);
                setEditingRoles({});
                setTempRoles({});
              } else {
                setError('Failed to update player: ' + result.error);
              }
            } catch (err) {
              setError('Error updating player: ' + err.message);
              console.error('Update player error:', err);
            } finally {
              setLoading(false);
            }
          };

          const startEditingRoles = (playerIndex, participant) => {
            setEditingPlayer(playerIndex);
            setTempRoles({
              wantsCaptain: participant.wantsCaptain,
              lockpicker: participant.lockpicker,
              healer: participant.healer,
              bard: participant.bard
            });
          };

          const updateTeamName = async (teamKey) => {
            const newName = tempTeamName;
            const updatedTeamNames = { ...teamNames, [teamKey]: newName };
            setTeamNames(updatedTeamNames);
            
            try {
              const updatedEventData = {
                ...eventData,
                teamNames: updatedTeamNames
              };
              
              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              await fetch(`${SCRIPT_URL}?${params.toString()}`);
              setEventData(updatedEventData);
              setEditingTeamName(null);
              setTempTeamName('');
            } catch (err) {
              console.error('Error updating team name:', err);
            }
          };

          const startEditingTeamName = (teamKey) => {
            setEditingTeamName(teamKey);
            setTempTeamName(teamNames[teamKey] || '');
          };

          const pickMap = async (map) => {
            const teamKey = currentMapPicker === 0 ? 'captain1' : 'captain2';
            
            const newSelectedMaps = [...selectedMaps, { ...map, pickedBy: teamKey }];
            setSelectedMaps(newSelectedMaps);
            
            const newAvailableMaps = parsedMaps.filter(m => m.id !== map.id);
            setParsedMaps(newAvailableMaps);
            
            try {
              const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
              audio.volume = 0.3;
              audio.play().catch(e => console.log('Audio play failed:', e));
            } catch (e) {
              console.log('Audio creation failed:', e);
            }
            
            const updatedEventData = {
              ...eventData,
              selectedMaps: newSelectedMaps,
              maps: newAvailableMaps,
              currentMapPicker: currentMapPicker === 0 ? 1 : 0
            };
            
            try {
              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });
              
              await fetch(`${SCRIPT_URL}?${params.toString()}`);
            } catch (err) {
              console.error('Error updating maps:', err);
            }
            
            if (newAvailableMaps.length === 0) {
              setView('complete');
            } else {
              setCurrentMapPicker(prev => prev === 0 ? 1 : 0);
            }
          };

          const getRoleIcons = (participant) => {
            const icons = [];
            if (participant.lockpicker) icons.push(<Key key="key" className="w-4 h-4 text-yellow-500" />);
            if (participant.healer) icons.push(<Heart key="heart" className="w-4 h-4 text-red-500" />);
            if (participant.bard) icons.push(<Music key="music" className="w-4 h-4 text-purple-500" />);
            return icons;
          };

          if (view === 'home') {
            return (
              <div className="min-h-screen bg-gradient-to-br from-amber-900 via-orange-800 to-red-900 p-8">
                <div className="max-w-2xl mx-auto">
                  {characterName && (
                    <div className="text-center mb-4">
                      <span className="bg-amber-600 text-white px-4 py-2 rounded-full text-sm">
                        Character: {characterName}
                      </span>
                    </div>
                  )}
                  <div className="bg-black/40 backdrop-blur-sm rounded-lg p-8 border-2 border-amber-600">
                    <div className="text-center mb-8">
                      <h1 className="text-5xl font-bold text-amber-400 mb-2">BEAR GUILD</h1>
                      <h2 className="text-2xl text-orange-300">Treasure Map Team Picker</h2>
                    </div>
                    
                    {error && (
                      <div className="bg-red-500/20 border border-red-500 text-red-200 px-4 py-3 rounded mb-4">
                        {error}
                      </div>
                    )}
                    
                    <div className="space-y-4">
                      <button onClick={() => setView('create')} className="w-full bg-amber-600 hover:bg-amber-700 text-white font-bold py-4 px-6 rounded-lg transition-colors text-xl">
                        Create New Event
                      </button>
                      <button onClick={() => setView('join')} className="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-4 px-6 rounded-lg transition-colors text-xl">
                        Join Existing Event
                      </button>
                    </div>
                  </div>
                </div>
                <div className="text-center mt-4 text-amber-600 text-sm">
                  v1.4.0 - Manual Player Addition
                </div>
              </div>
            );
          }

          if (view === 'create') {
            if (!discordUser) {
              return (
                <div className="min-h-screen bg-gradient-to-br from-amber-900 via-orange-800 to-red-900 p-8">
                  <div className="max-w-2xl mx-auto">
                    <div className="bg-black/40 backdrop-blur-sm rounded-lg p-8 border-2 border-amber-600 text-center">
                      <h2 className="text-3xl font-bold text-amber-400 mb-6">Authentication Required</h2>
                      <p className="text-orange-300 mb-6">You must log in with Discord to create an event.</p>
                      <button
                        onClick={loginWithDiscord}
                        className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-lg transition-colors text-xl flex items-center justify-center gap-3 mx-auto"
                      >
                        <svg className="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                          <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                      </button>
                      <button
                        onClick={() => setView('home')}
                        className="mt-4 text-orange-300 hover:text-orange-400 underline"
                      >
                        Back to Home
                      </button>
                    </div>
                  </div>
                  <div className="text-center mt-4 text-amber-600 text-sm">
                    v1.4.0 - Manual Player Addition
                  </div>
                </div>
              );
            }

            return (
              <div className="min-h-screen bg-gradient-to-br from-amber-900 via-orange-800 to-red-900 p-8">
                <div className="max-w-2xl mx-auto">
                  <div className="text-center mb-4">
                    <span className="bg-indigo-600 text-white px-4 py-2 rounded-full text-sm flex items-center gap-2 inline-flex">
                      <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                      </svg>
                      {discordUser.username}
                    </span>
                  </div>
                  <div className="bg-black/40 backdrop-blur-sm rounded-lg p-8 border-2 border-amber-600">
                    <h2 className="text-3xl font-bold text-amber-400 mb-6">Create Event</h2>
                    
                    {error && (
                      <div className="bg-red-500/20 border border-red-500 text-red-200 px-4 py-3 rounded mb-4">
                        {error}
                      </div>
                    )}
                    
                    <div className="space-y-4">
                      <div>
                        <label className="block text-orange-300 mb-2">Your Character Name</label>
                        <input type="text" value={characterName} onChange={(e) => setCharacterName(e.target.value)} className="w-full px-4 py-2 bg-black/60 border border-amber-600 rounded text-white" placeholder="Enter your name" />
                      </div>
                      
                      <div className="space-y-2">
                        <label className="block text-orange-300 mb-2">Your Roles</label>
                        <label className="flex items-center gap-2 text-orange-300 cursor-pointer">
                          <input type="checkbox" checked={wantsCaptain} onChange={(e) => setWantsCaptain(e.target.checked)} className="w-5 h-5" />
                          <Shield className="w-5 h-5" />
                          I want to be a Captain
                        </label>
                        <label className="flex items-center gap-2 text-orange-300 cursor-pointer">
                          <input type="checkbox" checked={isLockpicker} onChange={(e) => setIsLockpicker(e.target.checked)} className="w-5 h-5" />
                          <Key className="w-5 h-5 text-yellow-500" />
                          Lockpicker
                        </label>
                        <label className="flex items-center gap-2 text-orange-300 cursor-pointer">
                          <input type="checkbox" checked={isHealer} onChange={(e) => setIsHealer(e.target.checked)} className="w-5 h-5" />
                          <Heart className="w-5 h-5 text-red-500" />
                          Healer
                        </label>
                        <label className="flex items-center gap-2 text-orange-300 cursor-pointer">
                          <input type="checkbox" checked={isBard} onChange={(e) => setIsBard(e.target.checked)} className="w-5 h-5" />
                          <Music className="w-5 h-5 text-purple-500" />
                          Bard
                        </label>
                      </div>
                      
                      <div className="flex gap-4">
                        <button onClick={createEvent} disabled={!characterName.trim() || loading} className="flex-1 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg transition-colors">
                          {loading ? 'Creating...' : 'Create Event'}
                        </button>
                        <button onClick={() => setView('home')} disabled={loading} className="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-colors">
                          Cancel
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="text-center mt-4 text-amber-600 text-sm">
                  v1.4.0 - Manual Player Addition
                </div>
              </div>
            );
          }

          if (view === 'join') {
            if (!discordUser) {
              return (
                <div className="min-h-screen bg-gradient-to-br from-amber-900 via-orange-800 to-red-900 p-8">
                  <div className="max-w-2xl mx-auto">
                    <div className="bg-black/40 backdrop-blur-sm rounded-lg p-8 border-2 border-amber-600 text-center">
                      <h2 className="text-3xl font-bold text-amber-400 mb-6">Authentication Required</h2>
                      <p className="text-orange-300 mb-6">You must log in with Discord to join an event.</p>
                      <button
                        onClick={loginWithDiscord}
                        className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-lg transition-colors text-xl flex items-center justify-center gap-3 mx-auto"
                      >
                        <svg className="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                          <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        Login with Discord
                      </button>
                      <button
                        onClick={() => setView('home')}
                        className="mt-4 text-orange-300 hover:text-orange-400 underline"
                      >
                        Back to Home
                      </button>
                    </div>
                  </div>
                  <div className="text-center mt-4 text-amber-600 text-sm">
                    v1.4.0 - Manual Player Addition
                  </div>
                </div>
              );
            }

            return (
              <div className="min-h-screen bg-gradient-to-br from-amber-900 via-orange-800 to-red-900 p-8">
                <div className="max-w-2xl mx-auto">
                  <div className="text-center mb-4">
                    <span className="bg-indigo-600 text-white px-4 py-2 rounded-full text-sm flex items-center gap-2 inline-flex">
                      <svg className="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.