<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BEAR Guild - Treasure Map Team Picker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Discord OAuth Configuration
        const DISCORD_CLIENT_ID = '1428188591263191120';
        const REDIRECT_URI = 'https://barhopper404.github.io/bear-treasure-map-picker/';
        
        // IMPORTANT: Replace this with your Google Apps Script Web App URL
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwSZmzTPP43TD36KdccG4rw6P6NJtN2KbWBK8VW_OOHUzC3vE5NkrKN990EKThKAYU1/exec';
        
        // Lucide React icons as simple SVG components
        const Users = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
                <circle cx="9" cy="7" r="4"/>
                <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
        );
        
        const Shield = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
            </svg>
        );
        
        const Key = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <circle cx="7.5" cy="15.5" r="5.5"/>
                <path d="m21 2-9.6 9.6"/>
                <path d="m15.5 7.5 3 3L22 7l-3-3"/>
            </svg>
        );
        
        const Heart = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/>
            </svg>
        );
        
        const Music = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
        );
        
        const Copy = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
            </svg>
        );
        
        const Check = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <polyline points="20 6 9 17 4 12"/>
            </svg>
        );

        const RefreshCw = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M21 2v6h-6"/>
                <path d="M3 12a9 9 0 0 1 15-6.7L21 8"/>
                <path d="M3 22v-6h6"/>
                <path d="M21 12a9 9 0 0 1-15 6.7L3 16"/>
            </svg>
        );

        const Edit = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
            </svg>
        );

        const Trash = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
                <path d="M3 6h18"/>
                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/>
                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/>
            </svg>
        );

        function TreasureMapTeamPicker() {
          const [view, setView] = useState('home');
          const [eventId, setEventId] = useState('');
          const [eventData, setEventData] = useState(null);
          const [characterName, setCharacterName] = useState('');
          const [wantsCaptain, setWantsCaptain] = useState(false);
          const [isLockpicker, setIsLockpicker] = useState(false);
          const [isHealer, setIsHealer] = useState(false);
          const [isBard, setIsBard] = useState(false);
          const [linkCopied, setLinkCopied] = useState(false);
          const [captains, setCaptains] = useState([]);
          const [pickingCaptain, setPickingCaptain] = useState(0);
          const [firstPickerDeferred, setFirstPickerDeferred] = useState(false);
          const [teams, setTeams] = useState({ captain1: [], captain2: [] });
          const [availablePlayers, setAvailablePlayers] = useState([]);
          const [loading, setLoading] = useState(false);
          const [error, setError] = useState('');
          const [editingPlayer, setEditingPlayer] = useState(null);
          const [spinningWheel, setSpinningWheel] = useState(false);
          const [wheelNames, setWheelNames] = useState([]);
          const [currentWheelName, setCurrentWheelName] = useState('');
          const [captainChoiceTimer, setCaptainChoiceTimer] = useState(45);
          const [draftTimer, setDraftTimer] = useState(60);
          const [hasJoined, setHasJoined] = useState(false);
          const [isAutoPicking, setIsAutoPicking] = useState(false);
          const [justDrafted, setJustDrafted] = useState(null);
          const [isDrafting, setIsDrafting] = useState(false);
          const [draftTimerSetting, setDraftTimerSetting] = useState(60);
          const [captainChoiceTimerSetting, setCaptainChoiceTimerSetting] = useState(45);
          const [teamNames, setTeamNames] = useState({ captain1: '', captain2: '' });
          const [editingTeamName, setEditingTeamName] = useState(null);
          const [tempTeamName, setTempTeamName] = useState('');
          const [editingRoles, setEditingRoles] = useState({});
          const [tempRoles, setTempRoles] = useState({});
          const [discordUser, setDiscordUser] = useState(null);
          const [isAuthenticating, setIsAuthenticating] = useState(false);
          const [leaderboard, setLeaderboard] = useState([]);
          const [showWinnerSelect, setShowWinnerSelect] = useState(false);
          const [totalMaps, setTotalMaps] = useState(20);
          const [mapCoords, setMapCoords] = useState('');
          const [parsedMaps, setParsedMaps] = useState([]);
          const [selectedMaps, setSelectedMaps] = useState([]);
          const [currentMapPicker, setCurrentMapPicker] = useState(0);
          const [mapPickingStarted, setMapPickingStarted] = useState(false);
          const [showAddPlayer, setShowAddPlayer] = useState(false);
          const [newPlayerName, setNewPlayerName] = useState('');
          const [newPlayerCaptain, setNewPlayerCaptain] = useState(false);
          const [newPlayerLockpicker, setNewPlayerLockpicker] = useState(false);
          const [newPlayerHealer, setNewPlayerHealer] = useState(false);
          const [newPlayerBard, setNewPlayerBard] = useState(false);

          // Check for event ID in URL on load
          useEffect(() => {
            const urlParams = new URLSearchParams(window.location.search);
            const eventParam = urlParams.get('event');
            const codeParam = urlParams.get('code');
            
            if (codeParam) {
              handleDiscordCallback(codeParam);
            } else if (eventParam) {
              setEventId(eventParam);
              const savedDiscord = localStorage.getItem('bearDiscordUser');
              if (savedDiscord) {
                setView('join');
              }
            }
          }, []);

          useEffect(() => {
            if (characterName) {
              try {
                localStorage.setItem('bearCharacterName', characterName);
              } catch (e) {
                console.log('localStorage not available:', e);
              }
            }
            if (discordUser) {
              try {
                localStorage.setItem('bearDiscordUser', JSON.stringify(discordUser));
              } catch (e) {
                console.log('localStorage not available:', e);
              }
            }
          }, [characterName, discordUser]);

          useEffect(() => {
            try {
              const savedName = localStorage.getItem('bearCharacterName');
              if (savedName) {
                setCharacterName(savedName);
              }
              const savedDiscord = localStorage.getItem('bearDiscordUser');
              if (savedDiscord) {
                setDiscordUser(JSON.parse(savedDiscord));
              }
            } catch (e) {
              console.log('localStorage not available:', e);
            }
            
            fetchLeaderboard();
          }, []);

          const fetchLeaderboard = async () => {
            try {
              const response = await fetch(`${SCRIPT_URL}?action=getLeaderboard`);
              const result = await response.json();
              if (result.success) {
                setLeaderboard(result.leaderboard || []);
              }
            } catch (err) {
              console.error('Error fetching leaderboard:', err);
            }
          };

          const recordWinner = async (winningTeam) => {
            if (!confirm(`Confirm ${winningTeam === 'captain1' ? eventData?.teamNames?.captain1 || `Team 1 (${captains[0]?.name})` : eventData?.teamNames?.captain2 || `Team 2 (${captains[1]?.name})`} won?`)) {
              return;
            }

            setLoading(true);
            try {
              const params = new URLSearchParams({
                action: 'recordWinner',
                eventId: eventId,
                winningTeam: winningTeam
              });

              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();

              if (result.success) {
                setEventData(result.eventData);
                setShowWinnerSelect(false);
                alert('Winner recorded! Stats have been updated.');
              } else {
                setError('Failed to record winner: ' + result.error);
              }
            } catch (err) {
              setError('Error recording winner: ' + err.message);
            } finally {
              setLoading(false);
            }
          };

          const handleDiscordCallback = async (code) => {
            setIsAuthenticating(true);
            try {
              const params = new URLSearchParams({
                action: 'exchangeCode',
                code: code
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              if (result.success) {
                setDiscordUser(result.user);
                window.history.replaceState({}, document.title, window.location.pathname + (eventId ? `?event=${eventId}` : ''));
                
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('event')) {
                  setView('join');
                }
              } else {
                setError('Discord authentication failed: ' + result.error);
              }
            } catch (err) {
              setError('Error during Discord authentication: ' + err.message);
            } finally {
              setIsAuthenticating(false);
            }
          };

          const loginWithDiscord = () => {
            const authUrl = `https://discord.com/api/oauth2/authorize?client_id=${DISCORD_CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&scope=identify`;
            window.location.href = authUrl;
          };

          const logoutDiscord = () => {
            setDiscordUser(null);
            try {
              localStorage.removeItem('bearDiscordUser');
            } catch (e) {
              console.log('localStorage not available:', e);
            }
          };

          useEffect(() => {
            if ((view === 'lobby' || view === 'captainChoice' || view === 'teamPicking') && eventId) {
              const interval = setInterval(async () => {
                try {
                  const response = await fetch(`${SCRIPT_URL}?eventId=${eventId}`);
                  const result = await response.json();
                  if (result.success && result.eventData) {
                    const currentDataStr = JSON.stringify(eventData);
                    const newDataStr = JSON.stringify(result.eventData);
                    
                    if (currentDataStr !== newDataStr) {
                      setEventData(result.eventData);
                      
                      if (result.eventData.started && result.eventData.captains) {
                        setCaptains(result.eventData.captains);
                        
                        if (result.eventData.currentPicker !== pickingCaptain) {
                          setPickingCaptain(result.eventData.currentPicker || 0);
                        }
                        
                        const currentTeamsStr = JSON.stringify(teams);
                        const newTeamsStr = JSON.stringify(result.eventData.teams);
                        if (currentTeamsStr !== newTeamsStr && result.eventData.teams) {
                          setTeams(result.eventData.teams);
                        }
                        
                        const currentAvailableStr = JSON.stringify(availablePlayers);
                        const newAvailableStr = JSON.stringify(result.eventData.availablePlayers);
                        if (currentAvailableStr !== newAvailableStr && result.eventData.availablePlayers) {
                          setAvailablePlayers(result.eventData.availablePlayers);
                        }
                        
                        if (view === 'lobby' && result.eventData.started) {
                          setView('captainChoice');
                        }
                        if (view === 'captainChoice' && result.eventData.deferredFirstPick !== undefined) {
                          setFirstPickerDeferred(result.eventData.deferredFirstPick);
                          if (result.eventData.deferredFirstPick || (result.eventData.teams && (result.eventData.teams.captain1.length > 0 || result.eventData.teams.captain2.length > 0))) {
                            setView('teamPicking');
                          }
                        }
                        if (result.eventData.completed) {
                          setView('complete');
                        }
                      }
                    }
                  }
                } catch (err) {
                  console.error('Error polling for updates:', err);
                }
              }, 3000);
              
              return () => clearInterval(interval);
            }
          }, [view, eventId, eventData, teams, availablePlayers, pickingCaptain]);

          const generateEventId = () => {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
          };

          const createEvent = async () => {
            setLoading(true);
            setError('');
            
            const newEventId = generateEventId();
            const participant = {
              name: characterName,
              discordUser: discordUser,
              wantsCaptain: wantsCaptain,
              lockpicker: isLockpicker,
              healer: isHealer,
              bard: isBard,
              isMarshall: true
            };

            try {
              const params = new URLSearchParams({
                action: 'createEvent',
                eventId: newEventId,
                marshall: characterName,
                discordUser: JSON.stringify(discordUser),
                participantData: JSON.stringify([participant])
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              if (result.success) {
                setEventId(newEventId);
                setEventData(result.eventData);
                setView('lobby');
              } else {
                setError('Failed to create event: ' + result.error);
              }
            } catch (err) {
              setError('Error creating event. Please try again. Error: ' + err.message);
              console.error('Create event error:', err);
            } finally {
              setLoading(false);
            }
          };

          const joinEvent = async () => {
            if (hasJoined) {
              setError('You have already joined this event!');
              return;
            }

            setLoading(true);
            setError('');

            const participant = {
              name: characterName,
              discordUser: discordUser,
              wantsCaptain,
              lockpicker: isLockpicker,
              healer: isHealer,
              bard: isBard,
              isMarshall: false
            };

            try {
              const checkResponse = await fetch(`${SCRIPT_URL}?eventId=${eventId}`);
              const checkResult = await checkResponse.json();
              
              if (!checkResult.success) {
                setError('Event not found: ' + checkResult.error);
                setLoading(false);
                return;
              }

              if (checkResult.eventData.started) {
                setError('This event has already started and is locked.');
                setLoading(false);
                return;
              }

              const existingNames = checkResult.eventData.participants.map(p => p.name.toLowerCase());
              if (existingNames.includes(characterName.toLowerCase())) {
                setError('A player with this name has already joined. Please choose a different character name.');
                setLoading(false);
                return;
              }
              
              const params = new URLSearchParams({
                action: 'addParticipant',
                eventId: eventId,
                participantData: JSON.stringify(participant)
              });
              
              const response = await fetch(`${SCRIPT_URL}?${params.toString()}`);
              const result = await response.json();
              
              console.log('Join result:', result);
              
              if (result.success) {
                setEventData(result.eventData);
                setHasJoined(true);
                setView('lobby');
              } else {
                setError('Failed to join event: ' + (result.error || 'Unknown error') + (result.debug ? ' - Debug: ' + JSON.stringify(result.debug) : ''));
              }
            } catch (err) {
              setError('Error joining event. Please check the Event ID and try again. Error: ' + err.message);
              console.error('Join event error:', err);
            } finally {
              setLoading(false);
            }
          };

          const copyEventLink = () => {
            const link = `${window.location.origin}${window.location.pathname}?event=${eventId}`;
            navigator.clipboard.writeText(link);
            setLinkCopied(true);
            setTimeout(() => setLinkCopied(false), 2000);
          };

          const spinWheel = (players) => {
            return players[Math.floor(Math.random() * players.length)];
          };

          const animateWheelSpin = (names, callback) => {
            setWheelNames(names);
            setSpinningWheel(true);
            
            let count = 0;
            const spinDuration = 3000;
            const intervalTime = 100;
            const totalSpins = spinDuration / intervalTime;
            
            const interval = setInterval(() => {
              setCurrentWheelName(names[count % names.length].name);
              count++;
              
              if (count >= totalSpins) {
                clearInterval(interval);
                const winner = spinWheel(names);
                setCurrentWheelName(winner.name);
                
                setTimeout(() => {
                  setSpinningWheel(false);
                  callback(winner);
                }, 1000);
              }
            }, intervalTime);
          };

          const startEvent = async () => {
            const potentialCaptains = eventData.participants.filter(p => p.wantsCaptain);
            
            if (potentialCaptains.length < 2) {
              alert('Need at least 2 people willing to be captain!');
              return;
            }

            animateWheelSpin(potentialCaptains, (captain1) => {
              const remainingCaptains = potentialCaptains.filter(p => p.name !== captain1.name);
              
              setTimeout(() => {
                animateWheelSpin(remainingCaptains, async (captain2) => {
                  const firstPicker = Math.random() < 0.5 ? 0 : 1;
                  
                  const selectedCaptains = [captain1, captain2];
                  const nonCaptains = eventData.participants.filter(
                    p => p.name !== captain1.name && p.name !== captain2.name
                  );

                  const updatedEventData = {
                    ...eventData,
                    started: true,
                    captains: selectedCaptains,
                    firstPicker: firstPicker,
                    currentPicker: firstPicker,
                    availablePlayers: nonCaptains,
                    teams: { captain1: [], captain2: [] },
                    deferredFirstPick: false
                  };

                  try {
                    const params = new URLSearchParams({
                      action: 'updateEvent',
                      eventId: eventId,
                      eventData: JSON.stringify(updatedEventData)
                    });

                    await fetch(`${SCRIPT_URL}?${params.toString()}`);
                    
                    setCaptains(selectedCaptains);
                    setPickingCaptain(firstPicker);
                    setAvailablePlayers(nonCaptains);
                    setTeams({ captain1: [], captain2: [] });
                    setView('captainChoice');
                  } catch (err) {
                    setError('Error starting event: ' + err.message);
                  }
                });
              }, 1500);
            });
          };

          const deferFirstPick = async () => {
            setFirstPickerDeferred(true);
            
            const newCurrentPicker = pickingCaptain === 0 ? 1 : 0;
            setPickingCaptain(newCurrentPicker);
            
            const updatedEventData = {
              ...eventData,
              deferredFirstPick: true,
              currentPicker: newCurrentPicker
            };

            try {
              const params = new URLSearchParams({
                action: 'updateEvent',
                eventId: eventId,
                eventData: JSON.stringify(updatedEventData)
              });

              await fetch(`${SCRIPT_URL}?${params.toString()}`);
              setEventData(updatedEventData);
              setView('teamPicking');
            } catch (err) {
              setError('Error deferring pick: ' + err.message);
            }
          };

          const startDrafting = () => {
            setDraftTimer(draftTimerSetting);
            setView('teamPicking');
          };

          const handleCaptainTimeout = async () => {
            if (pickingCaptain === eventData.firstPicker) {
              const otherCaptain = pickingCaptain === 0 ? 1 : 0;
              setPickingCaptain(otherCaptain);
              setCaptainChoiceTimer(captainChoiceTimerSetting);
              
              const updatedEventData = {
                ...eventData,
                currentPicker: otherCaptain,
                firstPickerTimedOut: true
              };
              
              try {
                const params = new URLSearchParams({
                  action: 'updateEvent',
                  eventId: eventId,
                  eventData: JSON.stringify(updatedEventData)
                });
                await fetch(`${SCRIPT_URL}?${params.toString()}`);
                setEventData(updatedEventData);
              } catch (err) {
                console.error('Error updating after timeout:', err);
              }
            } else {
              const randomDefer = Math.random() < 0.5;
              if (randomDefer) {
                await deferFirstPick();
              } else {
                startDrafting();
              }
            }
          };

          const handleDraftTimeout = async () => {
            if (availablePlayers.length > 0 && !isAutoPicking) {
              setIsAutoPicking(true);
              const randomPlayer = availablePlayers[Math.floor(Math.random() * availablePlayers.length)];
              await pickPlayer(randomPlayer);
              setTimeout(() => setIsAutoPicking(false), 1000);
            }
          };

          useEffect(() => {
            if (view === 'captainChoice' && captainChoiceTimer > 0) {
              const timer = setTimeout(() => {
                setCaptainChoiceTimer(prev => prev - 1);
              }, 1000);
              return () => clearTimeout(timer);
            } else if (view === 'captainChoice' && captainChoiceTimer === 0) {
              handleCaptainTimeout();
            }
          }, [view, captainChoiceTimer]);

          useEffect(() => {
            if (view === 'teamPicking' && availablePlayers.length > 0 && draftTimer > 0 && !isAutoPicking) {
              const timer = setTimeout(() => {
                setDraftTimer(prev => prev - 1);
              }, 1000);
              return () => clearTimeout(timer);
            } else if (view === 'teamPicking' && draftTimer === 0 && availablePlayers.length > 0 && !isAutoPicking) {
              handleDraftTimeout();
            }
          }, [view, draftTimer, availablePlayers, isAutoPicking]);

          useEffect(() => {
            if (view === 'teamPicking' && !isAutoPicking) {
              setDraftTimer(draftTimerSetting);
            }
          }, [pickingCaptain, view, teams.captain1.length, teams.captain2.length, draftTimerSetting]);

          const pickPlayer = async (player) => {
            if (isDrafting) {
              return;
            }
            
            setIsDrafting(true);
            
            const teamKey = pickingCaptain === 0 ? 'captain1' : 'captain2';
            
            const newTeams = {
              ...teams,
              [teamKey]: [...teams[teamKey], player]
            };
            
            const newAvailablePlayers = availablePlayers.filter(p => p.name !== player.name);
            
            setTeams(newTeams);
            setAvailablePlayers(newAvailablePlayers);
            setDraftTimer(draftTimerSetting);
            setJustDrafted(player.name);
            setTimeout(() => setJustDrafted(null), 2000);
            
            try {
              const audio